/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef reflection_limited_TYPES_H
#define reflection_limited_TYPES_H

#include <Thrift.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>



namespace facebook { namespace thrift { namespace reflection { namespace limited {

enum TTypeTag {
  T_VOID = 1,
  T_BOOL = 2,
  T_BYTE = 3,
  T_I16 = 6,
  T_I32 = 8,
  T_I64 = 10,
  T_DOUBLE = 4,
  T_STRING = 11,
  T_STRUCT = 12,
  T_MAP = 13,
  T_SET = 14,
  T_LIST = 15,
  T_ENUM = 101,
  T_NOT_REFLECTED = 102
};

class SimpleType {
 public:

  SimpleType() : name("") {
  }

  virtual ~SimpleType() throw() {}

  TTypeTag ttype;
  std::string name;

  struct __isset {
    __isset() : ttype(false), name(false) {}
    bool ttype;
    bool name;
  } __isset;

  bool operator == (const SimpleType & rhs) const
  {
    if (!(ttype == rhs.ttype))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const SimpleType &rhs) const {
    return !(*this == rhs);
  }

  uint32_t read(facebook::thrift::protocol::TProtocol* iprot);
  uint32_t write(facebook::thrift::protocol::TProtocol* oprot) const;

};

class ContainerType {
 public:

  ContainerType() {
  }

  virtual ~ContainerType() throw() {}

  TTypeTag ttype;
  SimpleType subtype1;
  SimpleType subtype2;

  struct __isset {
    __isset() : ttype(false), subtype1(false), subtype2(false) {}
    bool ttype;
    bool subtype1;
    bool subtype2;
  } __isset;

  bool operator == (const ContainerType & rhs) const
  {
    if (!(ttype == rhs.ttype))
      return false;
    if (!(subtype1 == rhs.subtype1))
      return false;
    if (__isset.subtype2 != rhs.__isset.subtype2)
      return false;
    else if (__isset.subtype2 && !(subtype2 == rhs.subtype2))
      return false;
    return true;
  }
  bool operator != (const ContainerType &rhs) const {
    return !(*this == rhs);
  }

  uint32_t read(facebook::thrift::protocol::TProtocol* iprot);
  uint32_t write(facebook::thrift::protocol::TProtocol* oprot) const;

};

class ThriftType {
 public:

  ThriftType() : is_container(0) {
  }

  virtual ~ThriftType() throw() {}

  bool is_container;
  SimpleType simple_type;
  ContainerType container_type;

  struct __isset {
    __isset() : is_container(false), simple_type(false), container_type(false) {}
    bool is_container;
    bool simple_type;
    bool container_type;
  } __isset;

  bool operator == (const ThriftType & rhs) const
  {
    if (!(is_container == rhs.is_container))
      return false;
    if (__isset.simple_type != rhs.__isset.simple_type)
      return false;
    else if (__isset.simple_type && !(simple_type == rhs.simple_type))
      return false;
    if (__isset.container_type != rhs.__isset.container_type)
      return false;
    else if (__isset.container_type && !(container_type == rhs.container_type))
      return false;
    return true;
  }
  bool operator != (const ThriftType &rhs) const {
    return !(*this == rhs);
  }

  uint32_t read(facebook::thrift::protocol::TProtocol* iprot);
  uint32_t write(facebook::thrift::protocol::TProtocol* oprot) const;

};

class Argument {
 public:

  Argument() : key(0), name("") {
  }

  virtual ~Argument() throw() {}

  int16_t key;
  std::string name;
  ThriftType type;

  struct __isset {
    __isset() : key(false), name(false), type(false) {}
    bool key;
    bool name;
    bool type;
  } __isset;

  bool operator == (const Argument & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Argument &rhs) const {
    return !(*this == rhs);
  }

  uint32_t read(facebook::thrift::protocol::TProtocol* iprot);
  uint32_t write(facebook::thrift::protocol::TProtocol* oprot) const;

};

class Method {
 public:

  Method() : name("") {
  }

  virtual ~Method() throw() {}

  std::string name;
  ThriftType return_type;
  std::vector<Argument>  arguments;

  struct __isset {
    __isset() : name(false), return_type(false), arguments(false) {}
    bool name;
    bool return_type;
    bool arguments;
  } __isset;

  bool operator == (const Method & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(return_type == rhs.return_type))
      return false;
    if (!(arguments == rhs.arguments))
      return false;
    return true;
  }
  bool operator != (const Method &rhs) const {
    return !(*this == rhs);
  }

  uint32_t read(facebook::thrift::protocol::TProtocol* iprot);
  uint32_t write(facebook::thrift::protocol::TProtocol* oprot) const;

};

class Service {
 public:

  Service() : name(""), fully_reflected(0) {
  }

  virtual ~Service() throw() {}

  std::string name;
  std::vector<Method>  methods;
  bool fully_reflected;

  struct __isset {
    __isset() : name(false), methods(false), fully_reflected(false) {}
    bool name;
    bool methods;
    bool fully_reflected;
  } __isset;

  bool operator == (const Service & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(methods == rhs.methods))
      return false;
    if (!(fully_reflected == rhs.fully_reflected))
      return false;
    return true;
  }
  bool operator != (const Service &rhs) const {
    return !(*this == rhs);
  }

  uint32_t read(facebook::thrift::protocol::TProtocol* iprot);
  uint32_t write(facebook::thrift::protocol::TProtocol* oprot) const;

};

}}}} // namespace

#endif
